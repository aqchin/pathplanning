# astar implementation needs to go herefrom read_config import read_configimport rospyfrom Queue import PriorityQueuefrom cse_190_assi_3.msg import AStarPathclass AStar():    EMPTY = 0    START = 1    WALL = 2    PIT = 3    GOAL = 4    def __init__(self):        self.config = read_config()        self.pl_pub = rospy.Publisher(                "results/path_list",                AStarPath,                queue_size = 10        )        # get configs        map_size = self.config["map_size"]        start = self.config["start"]        goal = self.config["goal"]        walls = self.config["walls"]        pits = self.config["pits"]        # setup map        (ms_x, ms_y) = map_size        self.map = [[AStar.EMPTY for r in range(ms_y)] for c in range(ms_x)]        (st_x, st_y) = start        (gl_x, gl_y) = goal        self.map[st_x][st_y] = AStar.START        self.map[gl_x][gl_y] = AStar.GOAL        for [r, c] in walls:            self.map[r][c] = AStar.WALL        for [r, c] in pits:            self.map[r][c] = AStar.PIT        # perform astar        self.cost = 1        pq = PriorityQueue()        path_list = []        path_list.append(start)        pq.put((self.cost + self.manhattan(start), start, path_list))        while not pq.empty():            cur_node = pq.get()            (cur_cost, cur_pos, cur_pl) = cur_node            if (cur_pos == goal):                #print cur_pl                for pl in cur_pl:                    new_pl = AStarPath()                    new_pl.data = pl                    rospy.sleep(1)                    self.pl_pub.publish(new_pl)                break;            for p in self.next_paths(cur_pos):                new_cost = cur_cost - self.manhattan(cur_pos) + self.manhattan(p) + self.cost                pq.put((new_cost, p, cur_pl + [p]))    def manhattan(self, pos):        (pos_x, pos_y) = pos        (gl_x, gl_y) = self.config["goal"]        return abs(pos_x - gl_x) + abs(pos_y - gl_y)    def next_paths(self, pos):        (x, y) = pos        (len_x, len_y) = self.config["map_size"]        to_avoid = self.config["walls"] + self.config["pits"]        out = []        # up        if (y > 0):            if (self.map[x][y-1] not in to_avoid):                out.append([x, y-1])        # right        if (x < len_x-1):            if (self.map[x+1][y] not in to_avoid):                out.append([x+1, y])        # down        if(y < len_y-1):            if (self.map[x][y+1] not in to_avoid):                out.append([x, y+1])        # left        if(x > 0):            if (self.map[x-1][y] not in to_avoid):                out.append([x-1, y])        return outif __name__ == '__main__':    AStar()