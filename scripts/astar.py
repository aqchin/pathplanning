# astar implementation needs to go herefrom read_config import read_configfrom Queue import PriorityQueuedef astar():    EMPTY = 0    START = 1    WALL = 2    PIT = 3    GOAL = 4    config = read_config()    #self.pl_pub = rospy.Publisher(    #    "results/path_list",    #    AStarPath,    #    queue_size = 10    #)    # get configs    map_size = config["map_size"]    start = config["start"]    goal = config["goal"]    walls = config["walls"]    pits = config["pits"]    # setup map    (ms_x, ms_y) = map_size    map = [[EMPTY for r in range(ms_y)] for c in range(ms_x)]    (st_x, st_y) = start    (gl_x, gl_y) = goal    map[st_x][st_y] = START    map[gl_x][gl_y] = GOAL    for [r, c] in walls:        map[r][c] = WALL    for [r, c] in pits:        map[r][c] = PIT    # perform astar    cost = 1    pq = PriorityQueue()    path_list = []    path_list.append(start)    pq.put((cost + manhattan(start, goal), start, path_list))    while not pq.empty():        cur_node = pq.get()        (cur_cost, cur_pos, cur_pl) = cur_node        if (cur_pos == goal):            #print cur_pl            return cur_pl            #for pl in cur_pl:                #new_pl = AStarPath()                #new_pl.data = pl                #rospy.sleep(1)                #self.pl_pub.publish(new_pl)            #break;        for p in next_paths(cur_pos, map, map_size, walls, pits):            new_cost = cur_cost - manhattan(cur_pos, goal) + manhattan(p, goal) + cost            pq.put((new_cost, p, cur_pl + [p]))def manhattan(pos, goal):    (pos_x, pos_y) = pos    (gl_x, gl_y) = goal    return abs(pos_x - gl_x) + abs(pos_y - gl_y)def next_paths(pos, map, map_size, walls, pits):    (x, y) = pos    (len_x, len_y) = map_size    to_avoid = walls + pits    out = []    # up    if (y > 0):        if (map[x][y-1] not in to_avoid):            out.append([x, y-1])    # right    if (x < len_x-1):        if (map[x+1][y] not in to_avoid):            out.append([x+1, y])    # down    if(y < len_y-1):        if (map[x][y+1] not in to_avoid):            out.append([x, y+1])    # left    if(x > 0):        if (map[x-1][y] not in to_avoid):            out.append([x-1, y])    return out